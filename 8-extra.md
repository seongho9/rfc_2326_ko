# RFC 2326 : RTSP 1.0

## Connections

RTSP 요청은 다음 몇개의 방법으로 전송 될 수 있다.

- 지속적인 연결

  URL 스키마가 `rtsp:`이면 해당 방법을 사용한다.

  이 때, 신뢰할 수 있는(ex. TCP)프로토콜을 사용하여 연결을 해야한다.

- 요청/응답 당 하나의 연결

  이는 서버와 클라이언트가 각각 독립적인 연결을 맺을 때 유용

- 연결이 없는 모드(비연결 모드)

  URL 스키마가 `rtspu:`이면 해당 방법을 사용한다.

  이는 신뢰할 수 없는(ex. UDP)프로토콜을 사용하여 연결을 해도 된다.

  이는 데이터 스트리밍이 아닌 메타데이터만을 요청할 때 사용한다.

클라이언트는 요청을 서버는 응답을 받는 HTTP와 달리, RTSP는 클라이언트와 서버 두 노드가 요청을 생성하고 응답을 받을 수 있다. 하지만 서버가 클라이언트에게 접근할 수 있는 방법을 지니고 있어야 하고 방화벽 때문에 클라이언트와 서버 간 지속적인 연결을 가지고 있을 때 성립한다.

### Pipelining

클라이언트가 지속적인 연결이나 비연결 모드일 경우 요청을 파이프라인화 할 수 있다.

> <strong>파이프라인(pipeline)</strong>
>
> 여러 요청을 응답 대기 없이 전송하는 것

파이프라이닝에서 요청이 들어온 순서대로 처리하는 것을 엄격히 보장해야 한다.

### Reliability and Acknowledgements

RTSP 요청은 수신자가 명시적으로 응답(Acknowledge)해야 한다. 하지만 멀티캐스트 그룹으로 전송될 경우 응답이 필요하지 않다.

> <strong>멀티캐스트(Multicast)</strong>
>
> 네트워크 상에서 한 번의 데이터 전송으로 여러 수신자에게 데이터를 동시에 전달하는 전송방식
>
> 네트워크 대역폭을 효율적으로 사용하고 동일 데이터를 다수의 클라이언트에게 전송할 때 효과적
>
> 연결 지향적인 TCP와 같은 통신 말고 UDP와 같은 통신방식이 사용됨

요청에 대한 응답이 없는 경우, RTT만큼 기다렸다가 동일한 요청을 다시 보낼 수 있다(이 때, RTT는 초기 값인 500ms).

RTT의 측정은 TCP와 동일하게 이루어지며, 이전에 측정된 RTT 값을 캐싱하여 이후 연결에서도 사용 할 수 있다.

신뢰가능한 프로토콜에서 재전송은 전적으로 하위 전송계층에 의존해야한다.

- 이미 TCP 계층에서 신뢰성 보장을 위해 재전송을 수행하는데, 상위 계층인 RTSP에서 또 전송하면 안된다는 소리
- 이 때, 여러개의 요청이 도착 할 수 있기 때문이다.

이 때 중복의 모호성을 없애기 위해 general-header에 timestamp을 지원하며, 이를 통해 TCP의 Karn 알고리즘이 필요하지 않게 된다.

요청에서 CSeq헤더는 RTSP 요청마다 포함해야 하며, 각 요청은 고유한 시퀀스 번호를 가지며 요청마다 1씩 증가함

재전송시 CSeq 번호를 유지해야 하며, 이를 통해 서버는 동일 요청인지 판별하기 때문이다.

RTSP의 TCP/UDP의 기본포트는 모두 544 이며, TCP는 필수 구현요소이고 UDP는 선택요소이다.

패킷의 전송방식은 다양한 방식으로 캡슐화 혹은 전송 할 수 있다.

- RTSP 패킷의 단일 PDU로 캡슐화

  여러 RTSP 패킷이 동일한 엔드포인트(서버/클라이언트 간)에 전달될 경우, 이를 하위 통신계층의 PDU(Protocol Data Unit)으로 묶어서 보낼 수 있다.

- TCP 스트림으로 캡슐화

RTP/RTCP와 인터리브(Interleave) 될 수 있는데. 즉 TCP 스트림 안에서 데이터가 교차(interleave)되어 전송될 수 있다. 이는 네트워크 환경에 의해 전송이 불가능 할 경우 유용하다.

RTSP 메시지는 반드시 `Content-Length`헤더가 있어야 한다.
